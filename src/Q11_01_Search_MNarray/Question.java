package Q11_01_Search_MNarray;

/**
 * 问题：给定矩阵MxN，每一行，每一列都按升序排列，搜索某元素。
 * 输入：
 * 1，         2，       3，        4，       5
 * 2.2，   2.5，  3.5，   4.5，  5.5
 * 3.3,  3.7,  4.3,  5.3, 6.5
 * 11，     12，     13，      14，     15
 * @author Young
 *
 */
public class Question {

	/*
	 * solution: 采用递归搜索策略，根据条件二分搜索相应行和列 （逻辑不对，修改）
	 * 			从最右上角开始，重新整理逻辑..
	 * 			1. 比较arr[0][N]与key大小：
	 * 				如果arr[0][0]等于key，return arr[0][0]
	 * 				如果arr[0][1], arr[1][0]均大于key，没有该元素， return -1
	 * 				如果arr[0][1]大于key, 二分搜索列数组[arr[0][0], arr[1][0]..arr[M][0]
	 *                                    （1）搜索到相应元素
	 *                                    （2）找到新的行m = low-1，从arr[m][1]递归搜索
	 *              如果arr[1][0]大于key，二分搜索行数组arr[0]
	 *                                    （1） 搜索到相应元素
	 *                                    （2）找的新的列n = low-1，从arr[1][n]递归搜索
	 *              如果arr[0][1], arr[1][0]均小于key，递归搜索arr[1][1].
	 *          2. 终止条件：矩阵搜索完毕N+1 && M+1
	 *          
	 * solution: 采用递归搜索策略，根据条件二分搜索相应行和列
	 * 			1. 比较arr[0][0]与key大小：
	 * 				如果arr[0][0]等于key，return arr[0][0]
	 * 				如果arr[0][1], arr[1][0]均大于key，没有该元素， return -1
	 * 				如果arr[0][1]大于key, 二分搜索列数组[arr[0][0], arr[1][0]..arr[M][0]
	 *                                    （1）搜索到相应元素
	 *                                    （2）没有找到该元素 return -1
	 *              如果arr[1][0]大于key，二分搜索行数组arr[0]
	 *                                    （1） 搜索到相应元素
	 *                                    （2）没有找到该元素 return -1
	 *              如果arr[0][1], arr[1][0]均小于key，递归搜索arr[1][1]
	 *              或者 如果上述连个行列搜索返回 -1 && -1 == true，递归搜索arr[1][1]
	 *             
	 *          2. 终止条件：矩阵搜索完毕N+1 或 M+1
	 *          
	 *          时间复杂度，设m = n最坏：2*log(n!) = 
	 *          2* [log(n) + log(n-1) + ... + log(1)] >= n * log(n) - n = O(n*log(n))
	 *          证明见《数据结构与算法分析C语言描述 》p189
	 */
}
